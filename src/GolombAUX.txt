	int decoder()
	{
		BitStream bsR { binaryFile, 'r'}; 
		int q { 0 }; 
		int r { 0 };
		int n { 0 };
		
		// Determine unary Code
		int bitUnary {};
		while((bitUnary = bsR.read_bit()) == 1)
		{
			cout << "unaryCode: " << bitUnary << endl; 
			q++; 
		}
		//cout << "q: " << q << endl;
		
		// mGolomb is a power of 2
		if ((mGolomb & (mGolomb-1)) == 0)
		{
			cout << "DESCODIFICADOR - potencia de 2" << endl;
			int b = ceil(log2(mGolomb));		// bit number of the binary code (b bits)
			cout << "b: " << b << endl;
			//vector<int> binary = bsR.read_Nbits(b);
			vector<int> binary;
			int BITS = b;
			while(BITS != 0)
			{
				binary.push_back(bsR.read_bit());
				BITS--;
			}
			
			//r = binary_to_integer(binary, b-1); // Get the integer(remainder) of the binary code
			
			int weigth {b-1};	// peso mais alto (se b=3-->weightMSigBit = 2)
			// Applying the sum of the bit weights
			for (int i = 0; i < b; i++)
			{
				cout << binary[i];
				r += (pow(2,weigth) * binary[i]);
				weigth--;
			}
			cout << endl;
			cout << "r_final: " << r << endl;
			
			n = q * mGolomb + r;			
			n = unfold_n(n);

			return n;
			
		}else{	// mGolomb is not a power of 2 
		
			cout << "\nNAO potencia de 2:\n";
		
			int b = ceil(log2(mGolomb));   // bit number of the binary code 
			cout << "b: " << b << endl;
			//binaryCode of power diff of 2 has less than one bit
			// le os primeiros valores da codeword , mas n le o ultimo bit do binary Code
			//vector<int> binary = bsR.read_Nbits(b-1);  
			vector<int> binary;
			int BITS = b-1;
			while(BITS != 0)
			{
				binary.push_back(bsR.read_bit());
				BITS--;
			}
			//binary[b-1] = 0;	// add bit to binary code
			
			int weigth {b-2};
			for (int i = 0; i < b-1; i++)
			{
				cout << binary[i];
				r += (pow(2,weigth) * binary[i]);
				weigth--;
			}
			cout << endl;
			cout << "r_final: " << r << endl;
			
			//r = binary_to_integer(binary, b-2);
			//cout << "r: " << r << endl;
			
			/** nota: 
			* pow(2,b)-mGolomb: representa os primeiros valores de r que  
			*	       contem b bits de representacao 
			*/           
			if (r < (pow(2,b)-mGolomb))
			{
				cout << "aqui_first_R" << endl;
				n = q * mGolomb + r;			
				n = unfold_n(n);
				cout << "n: " << n << endl;
				return n;
			
			}else{
				cout << "aqui_LAST_R" << endl;
				
				// Como r > pow(2,b)-mGolomb, entao a representacao do binary Code passa a ter
				// mais um bit !!!! Logo, falta-nos ler 1 bit para juntar ao vetor binary
				
				cout << "size: " << binary.size() << endl;
				//binary[0] = bsR.read_bit(); 
				binary.push_back(bsR.read_bit());
				cout << "size: " << binary.size() << endl;
				
				//binary.push_back(bit);
				
				//binary.push_back(bsR.read_bit());	// ler o bit de menor peso
				

				r = 0; // r passa a ser diferente 
				int weigth {b-1};
				for (int i = 0; i < b; i++)
				{
					cout << binary[i];
					r += (pow(2,weigth) * binary[i]);
					weigth--;
				}
				cout << endl;
				cout << "r_final: " << r << endl;
				
				//n = mGolomb*q + (r-b);	// r nao e diretamente o binary Code 
				n = mGolomb*q + r;
				n = unfold_n(n - (pow(2, b) - mGolomb));
				//n = unfold_n(n);
				cout << "n: " << n << endl;
				
				/*
				r = 0;
				int weigth {0};
				// Applying the sum of the bit weights
				for (int i = b-1; i >= 0; i--) // da erro se n fizer aqui diretamente por causa do r
				{
					cout << binary[i] << endl;
					r += (pow(2,weigth) * binary[i]);
					weigth++;
				}
				n = mGolomb*q + r;
				n = unfold_n(n - (pow(2, b) - mGolomb));
				cout << "n: " << n << endl;*/
				return n; 
			}
		}
		
		return 0;
	}
